Great — let’s build a **student-friendly Hyperledger Fabric business network** implementation you can deploy to the Fabric **test network** (fabric-samples).
I'll give you:

1. A **simple chaincode (smart contract)** in **JavaScript** (fabric-contract-api) that models a Business Network (Asset + Participant + Transactions).
2. A **client script** (Node.js) to submit transactions (create asset, transfer, query).
3. **package.json** files and instructions to deploy to the Fabric test-network (fabric-samples/test-network).
4. Explanations, expected output, and viva notes — all in the same line-by-line, student-style format you prefer.

This is compact, exam-ready, and works with Fabric v2.x test-network from `fabric-samples`.

---

## 1) Concept & Design (very short)

We model a tiny Business Network with:

* **Asset:** `BusinessAsset` (id, name, owner, value)
* **Transactions:** `CreateAsset`, `TransferAsset`, `ReadAsset`, `GetAllAssets`
* **Owner/Participant:** owner is just an address string (client identity `mspId::id` stored as owner).
  We provide `InitLedger` to pre-seed some assets.

---

## 2) Chaincode — `lib/businessContract.js`

Create a folder `chaincode-js/business-network/` and inside `lib/businessContract.js`.

```javascript
/*
  businessContract.js
  --------------------------------------------------------------------------------
  Chaincode for a small Business Network using Fabric Contract API (JavaScript).
  Student-style: simple, commented, easy-to-read.
  --------------------------------------------------------------------------------
*/

'use strict';

const { Contract } = require('fabric-contract-api');

class BusinessContract extends Contract {

    // Initialize ledger with some sample assets (optional)
    async InitLedger(ctx) {
        // Sample initial assets
        const assets = [
            { id: 'ASSET1', name: 'Printer', owner: 'Org1MSP::User1', value: 500 },
            { id: 'ASSET2', name: 'Laptop',  owner: 'Org1MSP::User1', value: 1200 },
            { id: 'ASSET3', name: 'Desk',    owner: 'Org2MSP::User1', value: 200 }
        ];

        // Write each sample asset to world state
        for (const asset of assets) {
            asset.docType = 'businessAsset';
            await ctx.stub.putState(asset.id, Buffer.from(JSON.stringify(asset)));
            // log for clarity (helpful during tests)
            console.info(`Asset ${asset.id} initialized`);
        }
    }

    // Create a new asset
    // params: ctx, id, name, owner, value
    async CreateAsset(ctx, id, name, owner, value) {
        // Logic: check if asset already exists
        const exists = await this.AssetExists(ctx, id);
        if (exists) {
            throw new Error(`The asset ${id} already exists`);
        }

        // Build asset object
        const asset = {
            id,
            docType: 'businessAsset',
            name,
            owner,
            value: parseFloat(value)
        };

        // Store asset in world state
        await ctx.stub.putState(id, Buffer.from(JSON.stringify(asset)));
        return JSON.stringify(asset);
    }

    // Read an asset by id
    async ReadAsset(ctx, id) {
        const assetJSON = await ctx.stub.getState(id); // get state from ledger
        if (!assetJSON || assetJSON.length === 0) {
            throw new Error(`Asset ${id} does not exist`);
        }
        return assetJSON.toString();
    }

    // Helper: check if asset exists
    async AssetExists(ctx, id) {
        const assetJSON = await ctx.stub.getState(id);
        return assetJSON && assetJSON.length > 0;
    }

    // Transfer ownership of asset to newOwner
    // params: ctx, id, newOwner
    async TransferAsset(ctx, id, newOwner) {
        // Check asset exists
        const assetJSON = await ctx.stub.getState(id);
        if (!assetJSON || assetJSON.length === 0) {
            throw new Error(`Asset ${id} does not exist`);
        }

        // Parse and update owner
        const asset = JSON.parse(assetJSON.toString());
        asset.owner = newOwner;

        // Put updated object back
        await ctx.stub.putState(id, Buffer.from(JSON.stringify(asset)));
        return JSON.stringify(asset);
    }

    // Get all assets (range query)
    async GetAllAssets(ctx) {
        const allResults = [];
        // empty start/end -> get all keys
        const iterator = await ctx.stub.getStateByRange('', '');
        let res = await iterator.next();
        while (!res.done) {
            if (res.value && res.value.value.toString()) {
                const Key = res.value.key;
                let Record;
                try {
                    Record = JSON.parse(res.value.value.toString('utf8'));
                } catch (err) {
                    Record = res.value.value.toString('utf8');
                }
                allResults.push({ Key, Record });
            }
            res = await iterator.next();
        }
        await iterator.close();
        return JSON.stringify(allResults);
    }

    // Delete an asset
    async DeleteAsset(ctx, id) {
        const exists = await this.AssetExists(ctx, id);
        if (!exists) {
            throw new Error(`The asset ${id} does not exist`);
        }
        await ctx.stub.deleteState(id);
    }

}

module.exports = BusinessContract;
```

---

## 3) Chaincode entry point — `index.js`

Place in `chaincode-js/business-network/index.js`:

```javascript
'use strict';

const BusinessContract = require('./lib/businessContract');
module.exports.contracts = [ BusinessContract ];
```

This is the standard contract export for Fabric JavaScript chaincode packaging.

---

## 4) `package.json` for the chaincode

Place in `chaincode-js/business-network/package.json`:

```json
{
  "name": "business-network",
  "version": "1.0.0",
  "description": "Simple Business Network chaincode for students",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "author": "Student",
  "license": "Apache-2.0",
  "dependencies": {
    "fabric-contract-api": "^2.5.0"
  }
}
```

> NOTE: The exact version of `fabric-contract-api` should match your Fabric runtime version. Use `^2.x` for Fabric v2.x.

---

## 5) Simple client script (Node.js) to interact with chaincode

Create `client/submitTransactions.js` — this script assumes you have the Fabric test network running and the connection profiles and wallet in place (fabric-samples provides samples).

This is a *minimal* example using the Fabric Gateway SDK:

```javascript
/*
  submitTransactions.js
  Student-style client that submits CreateAsset and TransferAsset transactions.
  Requires: @hyperledger/fabric-network, and local wallet/connection profile.
*/

'use strict';

const { Gateway, Wallets } = require('fabric-network');
const path = require('path');
const fs = require('fs');

async function main() {
    try {
        // 1) load the connection profile (change path to match your test network)
        const ccpPath = path.resolve(__dirname, '..', 'fabric-samples', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
        const ccp = JSON.parse(fs.readFileSync(ccpPath, 'utf8'));

        // 2) wallet (localhost wallet created by fabric-samples)
        const walletPath = path.join(process.cwd(), 'wallet');
        const wallet = await Wallets.newFileSystemWallet(walletPath);

        // 3) identity to use (admin or user1)
        const identityLabel = 'appUser';
        const identity = await wallet.get(identityLabel);
        if (!identity) {
            console.log(`An identity for the user ${identityLabel} does not exist in the wallet`);
            console.log('Run the registerUser/enrollUser sample first');
            return;
        }

        // 4) connect gateway
        const gateway = new Gateway();
        await gateway.connect(ccp, {
            wallet,
            identity: identityLabel,
            discovery: { enabled: true, asLocalhost: true }
        });

        // 5) get network and contract
        const network = await gateway.getNetwork('mychannel');
        const contract = network.getContract('business-network'); // chaincode name

        // 6) submit transactions
        console.log('-> Submit CreateAsset ASSET100');
        await contract.submitTransaction('CreateAsset', 'ASSET100', 'OfficeChair', 'Org1MSP::User1', '150');
        console.log('*** Transaction CreateAsset has been submitted');

        console.log('-> Submit TransferAsset ASSET100 -> new owner Org2MSP::User2');
        await contract.submitTransaction('TransferAsset', 'ASSET100', 'Org2MSP::User2');
        console.log('*** Transaction TransferAsset has been submitted');

        // 7) evaluate query
        const result = await contract.evaluateTransaction('ReadAsset', 'ASSET100');
        console.log('*** Result from ReadAsset: ', result.toString());

        // 8) disconnect
        await gateway.disconnect();

    } catch (error) {
        console.error(`Error: ${error}`);
        process.exit(1);
    }
}

main();
```

> The client requires a prepared wallet and a connection profile. The `fabric-samples/test-network` scripts create wallets and admin/user identities using the `./network.sh` scripts — see deployment steps below.

---

## 6) How to deploy & test locally (Fabric test network — student steps)

> **Pre-reqs:** Docker, Docker Compose, Node.js, Go (for some tools), and `fabric-samples` cloned. Follow Hyperledger Fabric docs to install prerequisites.

1. Clone fabric-samples and go to test-network:

```bash
git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples/test-network
```

2. Bring up the test network and create channel (this provides peers, orderer, CAs, and sample wallets):

```bash
./network.sh up createChannel -c mychannel -ca
```

* This will create `organizations/peerOrganizations/...` folders and connection profiles.

3. Deploy the chaincode (from `test-network` folder — adjust `--ccp` path to your chaincode):

```bash
# from fabric-samples/test-network
./network.sh deployCC -ccn business-network -ccp ../../chaincode-js/business-network -ccl javascript
```

* `-ccn` = chaincode name, `-ccp` = path to chaincode package, `-ccl` = chaincode language

4. Install wallet + register user (fabric-samples has scripts in `test-network` sample which create appUser):

   * If using the test-network sample flow, the deploy scripts already register/enroll `appUser`. If not, use the `registerEnrollUser.js` script or the sample `enrollAdmin.js` & `registerUser.js`.

5. Run client script:

```bash
# from your project root
node client/submitTransactions.js
```

* This will submit `CreateAsset` and `TransferAsset` transactions and print the `ReadAsset` result.

6. Use `peer` CLI (in the test-network scripts) or the Fabric Explorer to inspect ledger, or query with the client.

---

## 7) Expected outputs (student-style)

* When you call `InitLedger` (optionally via CLI or client), the peer logs show assets created; world state contains `ASSET1`, `ASSET2`, `ASSET3`.
* `CreateAsset` transaction: returns the created asset JSON and writes it to world state.
* `TransferAsset` transaction: new owner set and stored.
* `ReadAsset` returns asset JSON; the console prints something like:

```
*** Result from ReadAsset:  {"id":"ASSET100","docType":"businessAsset","name":"OfficeChair","owner":"Org2MSP::User2","value":150}
```

---

## 8) Gas / Transaction Fee (Viva note)

* Hyperledger Fabric **does not use gas or Ether**. Transactions consume **endorsement resources** and **blockspace**, but there is **no gas price** — transaction fee = **0** on private Fabric networks.
* What you can observe: **latency** (ms) and **resource usage** (CPU, memory) and **endorsement time**, not gas.

---

## 9) Complexity & Viva Points (student-ready)

* **Where data is stored?** World state (CouchDB or LevelDB) + blockchain ledger (ordered blocks).
* **Transaction flow:** Client → Endorsing peers simulate → Proposal responses → Ordering service → Commit → World state updated.
* **Key functions:** `putState`, `getState`, `getStateByRange`, `deleteState`.
* **Access control:** Implemented at client (by identity) or using `clientIdentity` in chaincode for richer ACL.
* **Scaling:** Fabric channels and private data collections allow multi-tenant networks.
* **No gas**: Fabric differs from public chains (Ethereum).

---

## 10) Final notes & submission checklist for practical

* Place chaincode in: `fabric-samples/chaincode-js/business-network/` (or any folder you prefer).
* Update `package.json` and run `npm install` inside the chaincode folder so Fabric can package dependencies.
* Use `test-network` scripts to bring up network and deploy CC.
* Use sample `wallet` and `connection-org1.json` generated by test-network to run the client script.

---

If you want, I can:

* Produce a **ready-to-download zip** with all files (`lib/businessContract.js`, `index.js`, `package.json`, `client/submitTransactions.js`), or
* Generate a **step-by-step command list** with exact paths for the `fabric-samples` that matches your environment, or
* Add **more features** (participants, richer ACL, events emitted on transfer, query by owner).

Which of these would you like next?
